# Codebook.md
Richard Casto

2015-10-17

## Overview
This data set uses as its source the “Human Activity Recognition Using Smartphones” data set that can be found here…

http://archive.ics.uci.edu/ml/datasets/Human+Activity+Recognition+Using+Smartphones

This dataset is a modified version that combines the test and training data, extracts measurements that are for the mean and standard deviation, creates more descriptive names and finally aggregates on the combination of the subject and activity and calculates the mean of the selected measurements.

## Study Design
The initial source data was sourced from here and was downloaded October 17, 2015…

https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip

The raw data was generated from the embedded accelerometer and gyroscope from within a Samsung Galaxy S II smart phone by 30 volunteers within an age bracket of 19 to 48 years.  Each person performed six different activities (WALKING, WALKING_UPSTAIRS, WALKING_DOWNSTAIRS, SITTING, STANDING, LAYING) while wearing the smart phone on their waist.

Six axis data (three axis each from the accelerometer and gyroscope) were captured at a constant rate of 50 Hz.  These were then filtered using low pass Butterworth filter to remove noise.  The signals were also broken out into “Body” and “Gravity” acceleration signals using another low pass Butterworth filter with a corner frequency of 0.3 Hz to ensure only low frequency components remain.

Linear acceleration and angular velocity values were derived from the data above to calculate “Jerk” signals.  Additionally, the “Magnitude” of the three dimensional signals was calculated using the Euclidean norm.  While the above values are all in the time domain (using a “t” prefix), additional frequency domain signals (using a “f” prefix) were calculated by using a Fast Fourier Transform.

The experiment was observed and the activity label for each action was recorded manuals.  Seventy percent of the volunteers were selected to generate training data while the remaining thirty percent generated the test data.  Ultimately this generated 561 measurements that is a combination of time and frequency domain.

The original codebook is found within the source data listed above.  While the above summarizes the initial data used for this codebook, but does not define the data in this codebook.  This codebook defines a tidy dataset that was generated by processing the above experimental data.  The goals of this tidy data set are…

1.	Merges the training and the test sets to create one data set.
2.	Extracts only the measurements on the mean and standard deviation for each measurement. 
3.	Uses descriptive activity names to name the activities in the data set
4.	Appropriately labels the data set with descriptive variable names. 
5.	From the data set in step 4, creates a second, independent tidy data set with the average of each variable for each activity and each subject.

Key points worth discussing are…
1.	What data did I use to merge?
2.	What measurements are capturing “mean” and “standard deviation”?
3.	How did I determine the descriptive activity names?
4.	How did I create appropriate labels that are descriptive?
5.	What is the format of the tidy data set?

## What data was used?
Generally speaking the following data is provided in the original data set…

“Various Inertial Signal files” (training and test).  This is raw data that has not been processed into values such as Jerk, Magnitude, etc.  Most importantly, this data does not include any calculated Mean or Standard Deviation values.  Because of that fact I do not even attempt to include this data as it would be excluded when I limit the final data set to only include the “Mean” and “Standard Deviation” values.

* “X_Train.txt files” (training and test).  This is the processed data that includes the calculations I am interested in.

* “Y_Train.txt files” (training and test).  This contains the training and test data set measurement labels

* “Subject_Train.txt and Subject_Test.txt”.  This contains the subject identifiers for the test and train data.

## What “mean” and “standard deviation” measurements were included and excluded?
The code book for the source data set speaks specifically to a set of variables that used the classic definition of calculations for “mean” and “standard deviation”.  Those variables all had a suffix of…

* -mean()
* -mean()-X
* -mean()-Y
* -mean()-Z
* -std()
* -std()-X
* -std()-Y
* -std()-Z

Any variable that had those suffixes were included in our final tidy data set because they were pure mean and standard deviation calculations.  Some other calculations use weighted averaging (weighting not defined and a suffix of “-meanFreq()”) or use an average within a window (window not defined and a prefix of “angle”) and while their labels include the word “Mean” in them, the description of the calculation is deemed as not being a true “mean” values.  **Because of this, I feel they do not fit the definition states in the goals and are not included in the final tidy data set.**

## How was the activity names sourced?
The “activity_labels.txt” file maps activity identifier to a friendly name.

## How was the descriptive measurement labels created?
The source data provides a list of features named “features.txt”.  This defined the original 561 measurements and their names.  Other documentation within the original codebook talks to how the variables were named.  Many parts of the name used abbreviations that may or may not be clear to the consumer of the data.  So I have created more descriptive names by expanding abbreviations and also removing various special characters (such as hyphens, parentheses, periods, etc.)

* Time = Time domain
* Frequency = Frequency domain
* Body = Body value
* Gravity = Gravity value
* Accelerometer = Sourced via the Accelerometer
* Gyroscope = Sourced via the Gyroscope
* Magnitude = Three axis magnitude
* Jerk = Acceleration Jerk
* XAxis = X Axis only
* YAxis = Y Axis only
* ZAxis = Z Axis only
* Mean = Mathematical Mean
* StandardDeviation = Mathematical Standard Deviation

These can be combined to build the names in the final data set.  So for example...

"TimeBodyAccelerometerJerkMeanZAxis" is...

"The time domain jerk measurement of the body along the Z axis as measured by the accelerometer."

Each of the variables in the codebook section below can use this method to define it's meaning.

## What format is used for the tidy data set?
The “Wide” format (variable/column per measurement) was used.  The tidy data set follows the following rules for a wide format…
1.	One observation per row (in this case aggregate per subject and activity)
2.	Each variable is in one column only

## Code Book
In the data set the first two variables define the subject identifier and the activity.  The remaining variables define the mathematical mean of the source data on a per subject and activity basis.  Descriptive names can be decoded using the information provided above that explains how the descriptive names were generated (and how to decode their meaning).

The units for accelerometer measurements uses a standard “g” (standard value of gravitational acceleration at sea level on Earth) that has been normalized to a -1 to 1 range.  The units for the gyroscope measurements uses radians/second that has been normalized to a -1 to 1 range.

Below is a complete list of the variables that exist within the tidy data set…

* Subject
* Activity
* TimeBodyAccelerometerMeanXAxis
* TimeBodyAccelerometerMeanYAxis
* TimeBodyAccelerometerMeanZAxis
* TimeBodyAccelerometerStandardDeviationXAxis
* TimeBodyAccelerometerStandardDeviationYAxis
* TimeBodyAccelerometerStandardDeviationZAxis
* TimeGravityAccelerometerMeanXAxis
* TimeGravityAccelerometerMeanYAxis
* TimeGravityAccelerometerMeanZAxis
* TimeGravityAccelerometerStandardDeviationXAxis
* TimeGravityAccelerometerStandardDeviationYAxis
* TimeGravityAccelerometerStandardDeviationZAxis
* TimeBodyAccelerometerJerkMeanXAxis
* TimeBodyAccelerometerJerkMeanYAxis
* TimeBodyAccelerometerJerkMeanZAxis
* TimeBodyAccelerometerJerkStandardDeviationXAxis
* TimeBodyAccelerometerJerkStandardDeviationYAxis
* TimeBodyAccelerometerJerkStandardDeviationZAxis
* TimeBodyGyroscopeMeanXAxis
* TimeBodyGyroscopeMeanYAxis
* TimeBodyGyroscopeMeanZAxis
* TimeBodyGyroscopeStandardDeviationXAxis
* TimeBodyGyroscopeStandardDeviationYAxis
* TimeBodyGyroscopeStandardDeviationZAxis
* TimeBodyGyroscopeJerkMeanXAxis
* TimeBodyGyroscopeJerkMeanYAxis
* TimeBodyGyroscopeJerkMeanZAxis
* TimeBodyGyroscopeJerkStandardDeviationXAxis
* TimeBodyGyroscopeJerkStandardDeviationYAxis
* TimeBodyGyroscopeJerkStandardDeviationZAxis
* TimeBodyAccelerometerMagnitudeMean
* TimeBodyAccelerometerMagnitudeStandardDeviation
* TimeGravityAccelerometerMagnitudeMean
* TimeGravityAccelerometerMagnitudeStandardDeviation
* TimeBodyAccelerometerJerkMagnitudeMean
* TimeBodyAccelerometerJerkMagnitudeStandardDeviation
* TimeBodyGyroscopeMagnitudeMean
* TimeBodyGyroscopeMagnitudeStandardDeviation
* TimeBodyGyroscopeJerkMagnitudeMean
* TimeBodyGyroscopeJerkMagnitudeStandardDeviation
* FrequencyBodyAccelerometerMeanXAxis
* FrequencyBodyAccelerometerMeanYAxis
* FrequencyBodyAccelerometerMeanZAxis
* FrequencyBodyAccelerometerStandardDeviationXAxis
* FrequencyBodyAccelerometerStandardDeviationYAxis
* FrequencyBodyAccelerometerStandardDeviationZAxis
* FrequencyBodyAccelerometerJerkMeanXAxis
* FrequencyBodyAccelerometerJerkMeanYAxis
* FrequencyBodyAccelerometerJerkMeanZAxis
* FrequencyBodyAccelerometerJerkStandardDeviationXAxis
* FrequencyBodyAccelerometerJerkStandardDeviationYAxis
* FrequencyBodyAccelerometerJerkStandardDeviationZAxis
* FrequencyBodyGyroscopeMeanXAxis
* FrequencyBodyGyroscopeMeanYAxis
* FrequencyBodyGyroscopeMeanZAxis
* FrequencyBodyGyroscopeStandardDeviationXAxis
* FrequencyBodyGyroscopeStandardDeviationYAxis
* FrequencyBodyGyroscopeStandardDeviationZAxis
* FrequencyBodyAccelerometerMagnitudeMean
* FrequencyBodyAccelerometerMagnitudeStandardDeviation
* FrequencyBodyAccelerometerJerkMagnitudeMean
* FrequencyBodyAccelerometerJerkMagnitudeStandardDeviation
* FrequencyBodyGyroscopeMagnitudeMean
* FrequencyBodyGyroscopeMagnitudeStandardDeviation
* FrequencyBodyGyroscopeJerkMagnitudeMean
* FrequencyBodyGyroscopeJerkMagnitudeStandardDeviation
